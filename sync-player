#!/usr/bin/env perl
use strict;
use warnings;
use v5.32;
use FindBin;
use lib "$FindBin::RealBin";
use Color qw(red blue cyan);
use Data::Printer;
use Path::Class qw(file dir);
use File::Copy::Recursive qw(fcopy pathmk);
use Types::Standard qw(Object InstanceOf ArrayRef);
use Type::Params qw(compile);

# Todo:
# * Configuration to a file
# * Determine copy if file is different in size
# * Single files instead of directories


# Helper Functions to create data-structure
sub sync {
    my ( $destination ) = @_;
    $destination = dir($destination);
    
    my $music = dir("/mnt/daten/Musik");
    return sub {
        my ( $folder, %attr ) = @_;
        my $recursive = $attr{Recursive} // 1;
        return Synchronize->new(
            source      => $music->subdir($folder),
            destination => $destination->subdir($folder),
            recursive   => $recursive,
        );
    }
}

*d2 = sync("/media/david/D2/MUSIC");
#*sd = sync("/media/david/A770-7A18");

# Folders to Synchronize
my @synchronize = (
    d2("2018"), d2("2019"), d2("2020"), d2("2021"), d2("2022-2"), d2("2wei"), d2("8 Graves"), 
    d2("Adele"), d2("Apashe"),
    d2("Best of Yiruma"),
    d2("Daft Punk"), d2("Dub Fx"),
    d2("Enigma"), d2("E Nomine"), d2("Enya/Very Best of Enya"),
    d2("Foo Fighters"),
    d2("Juno Reactor"),
    d2("Games", Recursive => 0),
);

# Get all changes needed - with deletion of files first
my @changes = 
    sort {
          $a->[0] eq 'COPY'   && $b->[0] eq 'DELETE' ?  1
        : $a->[0] eq 'DELETE' && $b->[0] eq 'COPY'   ? -1
        : 0
    }
    map { $_->diff } @synchronize;

# Generate a summary
my $copies    = scalar grep { $_->[0] =~ m/COPY/   } @changes;
my $deletions = scalar grep { $_->[0] =~ m/DELETE/ } @changes;

printf "Summary:\nCopies: %d\nDeletions: %s\n\n", $copies, $deletions;
for my $change ( @changes ) {
    execute_operation(@$change);
}



### Functions
sub execute_operation {
    my ($operation, $x, $y) = @_;
    
    if ( $operation eq 'COPY' ) {
        printf "%s %s => %s\n", red("Copying"), blue($x), cyan($y);
        fcopy($x,$y);
    }
    elsif ( $operation eq 'DELETE' ) {
        printf "%s %s\n", red("Deleting"), blue($x);
        $x->remove;
    }
    else {
        die "Unknown Operation [$operation]\n";
    }
}

BEGIN {
    package Synchronize;
    use Moose;
    use Path::Class;
    use List::Util qw(any);
    use Types::Standard qw(InstanceOf Bool);
    use Type::Params qw(compile);
    use Moose::Util::TypeConstraints;
    use namespace::autoclean;

    class_type 'PathClassDir', { class => 'Path::Class::Dir' };

    coerce 'PathClassDir',
        from 'Str',
        via { dir($_) };

    has 'source' => (
        is       => 'ro',
        isa      => 'PathClassDir',
        required => 1,
    );

    has 'destination' => (
        is       => 'ro',
        isa      => 'PathClassDir',
        required => 1,
    );

    has 'recursive' => (
        is       => 'ro',
        isa      => Bool,
        default  => 1,
    );

    sub source_files {
        my ( $self ) = @_;
        return list_files($self->source, Recursive => $self->recursive);
    }

    sub destination_files {
        my ( $self ) = @_;
        return list_files($self->destination, Recursive => $self->recursive);
    }

    sub diff {
        my ( $self ) = @_;
           
        # Changes operation
        my @changes;
        
        # Fetch file list only once
        my $src = RelativeFolder->from_absolute(
            root  => $self->source,
            files => $self->source_files,
        );
        my $dst = RelativeFolder->from_absolute(
            root  => $self->destination,
            files => $self->destination_files,
        );
        
        # Which files should be deleted from DST
        for my $file ( $dst->all_files ) {
            if ( not $src->contains($file) ) {
                push @changes, [DELETE => $dst->root->file($file)];
            }
        }
        
        # Look which files should be copied from SRC to DST
        for my $file ( $src->all_files ) {
            if ( not $dst->contains($file) ) {
                push @changes, [COPY => $src->root->file($file), $dst->root->file($file)];
            }
        }
        
        return wantarray ? @changes : \@changes;
    }


    # returns full path of every file from a directory
    sub list_files {
        my ($dir, %attr) = @_;
        my $recursive = $attr{Recursive} // 1;
        
        my $content = [];
        if ( -d $dir ) {
            if ( $recursive ) {
                $content = $dir->traverse(sub {
                    my ($child, $cont, $content) = @_;
                
                    if (-f $child) {
                        push @$content, $child;
                    }
                    else {
                        $cont->($content);
                    }
                
                    return $content;
                }, []);
            }
            else {
                while ( my $x = $dir->next ) {
                    push @$content, $x if -f $x;
                }
            }
        }
        
        return $content;
    }
    
    package RelativeFolder;
    use Moose;
    use Types::Standard qw(Any InstanceOf ArrayRef);
    use Type::Params qw(compile_named);
    use List::Util qw(any);
    
    has 'root' => (
        is       => 'ro',
        isa      => 'Path::Class::Dir',
        required => 1,
    );
    
    has 'files' => (
        traits   => ['Array'],
        is       => 'ro',
        isa      => 'ArrayRef[Path::Class::File]',
        required => 1,
        handles  => {
            all_files => 'elements',
        }
    );
    
    sub contains {
        my ( $self, $file ) = @_;
        
        if ( any { $file eq $_ } $self->all_files ) {
            return 1;
        }
        
        return 0;
    }
    
    # Class Method
    sub from_absolute {
        state $check = compile_named(
            { head => 1 },
            root  => InstanceOf['Path::Class::Dir'],
            files => ArrayRef[InstanceOf['Path::Class::Entity']],
        );
        my ( $class, $arg ) = &$check;
        
        return RelativeFolder->new({
            root  => $arg->{root},
            files => [ map { $_->relative($arg->{root}) } @{$arg->{files}} ],
        });
    }
    
    __PACKAGE__->meta->make_immutable;
}








