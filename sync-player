#!/usr/bin/env perl
use strict;
use warnings;
use v5.32;
use FindBin;
use lib "$FindBin::RealBin";
use Color qw(red blue cyan);
use Data::Printer;
use Path::Class qw(file dir);
use File::Copy::Recursive qw(fcopy pathmk);
use Types::Standard qw(Object InstanceOf ArrayRef);
use Type::Params qw(compile);

# Todo:
# * Configuration to a file
# * Determine copy if file is different in size
# * Single files instead of directories


# Helper Functions to create data-structure
sub sync {
    my ( $destination ) = @_;
    $destination = dir($destination);
    
    my $source = dir("/mnt/daten/Musik");
    return sub {
        my ( $folder, %attr ) = @_;
        my $recursive = $attr{Recursive} // 1;
        return Synchronize->new(
            source      => Directory->new({ dir => $source->subdir($folder)      }),
            destination => Directory->new({ dir => $destination->subdir($folder) }),
            recursive   => $recursive,
        );
    }
}

*d2 = sync("/media/david/D2/MUSIC");
*sd = sync("/media/david/A770-7A18");

# Folders to Synchronize
my @synchronize = (
    d2("2018"), d2("2019"), d2("2020"), d2("2021"), d2("2022-2"), d2("2wei"), d2("8 Graves"), 
    d2("Adele"), d2("Apashe"),
    d2("Best of Yiruma"),
    d2("Daft Punk"), d2("Dub Fx"),
    d2("Enigma"), d2("E Nomine"), d2("Enya/Very Best of Enya"),
    d2("Foo Fighters"),
    d2("Juno Reactor"),
    d2("Games", Recursive => 0),
);



# Get all changes needed - with deletion of files first
my @changes = 
    sort {
          $a->[0] eq 'COPY'   && $b->[0] eq 'DELETE' ?  1
        : $a->[0] eq 'DELETE' && $b->[0] eq 'COPY'   ? -1
        : 0
    }
    map { $_->diff } @synchronize;

# Generate a summary
my $copies    = scalar grep { $_->[0] =~ m/COPY/   } @changes;
my $deletions = scalar grep { $_->[0] =~ m/DELETE/ } @changes;

printf "Summary:\nCopies: %d\nDeletions: %s\n\n", $copies, $deletions;
for my $change ( @changes ) {
    execute_operation(@$change);
}



### Functions
# Returns a structure with the root and all files in an array
sub make_relative_to {
    state $check = compile(
        InstanceOf['Path::Class::Dir'],
        ArrayRef[InstanceOf['Path::Class::Entity']],
    );
    my ( $root, $files ) = &$check;
    
    return {
        Root  => $root,
        Files => [ map { $_->relative($root) } @$files ],
    };
}

sub execute_operation {
    my ($operation, $x, $y) = @_;
    
    if ( $operation eq 'COPY' ) {
        printf "%s %s => %s\n", red("Copying"), blue($x), cyan($y);
#        fcopy($x,$y);
    }
    elsif ( $operation eq 'DELETE' ) {
        printf "%s %s\n", red("Deleting"), blue($x);
#        $x->remove;
    }
    else {
        die "Unknown Operation [$operation]\n";
    }
}

# Classes
BEGIN {
    package Directory;
    use Moose;
    use Moose::Util::TypeConstraints;
    use Types::Standard qw(Object InstanceOf Bool);
    use Type::Params qw(compile_named);
    use List::Util qw(any);
    use Path::Class;
    use Data::Printer;
    use namespace::autoclean;
    
    class_type 'PathClassDir', { class => 'Path::Class::Dir' };
    coerce 'PathClassDir',
        from 'Str',
        via { dir($_) };
    
    has 'dir' => (
        is       => 'ro',
        isa      => 'PathClassDir',
        required => 1,
        coerce   => 1,
    );
    
    sub files {
        state $check = compile_named(
            { head => [ Object ] },
            Recursive => Bool, { default => 1 },
        );
        my ( $self, $arg ) = &$check;
        
        # Content to build
        my $files = [];
        
        # only run if directory exists
        if ( -d $self->dir ) {
            if ( $arg->{Recursive} ) {
                $files = $self->dir->traverse(sub {
                    my ($child, $cont, $files) = @_;
                
                    if (-f $child) {
                        push @$files, $child;
                    }
                    else {
                        $cont->($files);
                    }
                
                    return $files;
                }, []);
            }
            else {
                while ( my $child = $self->dir->next ) {
                    push @$files, $child if -f $child;
                }
            }
        }
        
        return $files;
    }
    
    sub diff {
        state $check = compile_named(
            { head => [ Object, InstanceOf['Directory'] ] },
            Recursive => Bool, { default => 1 },
        );
        my ( $self, $dest, $arg ) = &$check;
        
        # Changes operation
        my @changes;
        
        # Fetch file list only once
        my $src = main::make_relative_to($self->dir, $self->files(Recursive => $arg->{Recursive}));
        my $dst = main::make_relative_to($dest->dir, $dest->files(Recursive => $arg->{Recursive}));
        
        # Which files should be deleted from DST
        for my $file ( @{$dst->{Files}} ) {
            if ( any { $file eq $_ } @{$src->{Files}} ) {
            }
            else {
                push @changes, [DELETE => $dst->{Root}->file($file)];
            }
        }
        
        # Look which files should be copied from SRC to DST
        for my $file ( @{$src->{Files}} ) {
            if ( any { $file eq $_ } @{$dst->{Files}} ) {
            }
            else {
                push @changes, [COPY => $src->{Root}->file($file), $dst->{Root}->file($file)];
            }
        }
        
        return wantarray ? @changes : \@changes;
    }
    
    __PACKAGE__->meta->make_immutable;

    
    package Synchronize;
    use Moose;
    use namespace::autoclean;
    
    has 'source' => (
        is       => 'ro',
        isa      => 'Directory',
        required => 1,
    );
    
    has 'destination' => (
        is       => 'ro',
        isa      => 'Directory',
        required => 1,
    );
    
    has 'recursive' => (
        is      => 'ro',
        isa     => 'Bool',
        default => 1,
    );
    
    sub diff {
        my ( $self ) = @_;
        my $diff = $self->source->diff($self->destination, Recursive => $self->recursive);
        return wantarray ? @$diff : $diff;
    }
    
    __PACKAGE__->meta->make_immutable;
}








