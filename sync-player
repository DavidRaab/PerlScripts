#!/usr/bin/env perl
use strict;
use warnings;
use v5.32;
use FindBin;
use lib "$FindBin::RealBin";
use Color qw(red blue cyan);
use Data::Printer;
use Path::Class qw(file dir);
use File::Copy::Recursive qw(fcopy pathmk);
use Getopt::Long;

# Todo:
# * Configuration to a file
# * Determine copy if file is different in size
# * Single files instead of directories

my $force = 0;
GetOptions(
    "f|force" => \$force,
) or die "Error in command line arguments\n";

# Helper Functions to create data-structure
sub sync {
    my ( $destination ) = @_;
    $destination = dir($destination);
    
    my $music = dir("/mnt/daten/Musik");
    return sub {
        my ( $folder, %attr ) = @_;
        my $recursive = $attr{Recursive} // 1;
        return Synchronize->new(
            source      => $music->subdir($folder),
            destination => $destination->subdir($folder),
            recursive   => $recursive,
        );
    }
}

*d2 = sync("/media/david/D2/MUSIC");
#*sd = sync("/media/david/A770-7A18");

# Folders to Synchronize
my @synchronize = (
    d2("2018"), d2("2019"), d2("2020"), d2("2021"), d2("2022-2"), d2("2wei"), d2("8 Graves"), 
    d2("Adele"), d2("Apashe"),
    d2("Best of Yiruma"),
    d2("Daft Punk"), d2("Dub Fx"),
    d2("Enigma"), d2("E Nomine"), d2("Enya/Very Best of Enya"),
    d2("Foo Fighters"),
    d2("Juno Reactor"),
    d2("Games", Recursive => 0),
);

# All changes
my @changes = map { $_->diff } @synchronize;

# cata example to count copies and deletions
sub count_operations {
    my ( @ops ) = @_;

    my $amount = cata_operations({
        COPY   => sub { my ($op,$s) = @_; [ $s->[0] + 1, $s->[1]     ] },
        DELETE => sub { my ($op,$s) = @_; [ $s->[0]    , $s->[1] + 1 ] },
    }, [0,0], @ops);
    
    return {
        Copies    => $amount->[0],
        Deletions => $amount->[1],
    };
}

my $amount = count_operations(@changes);


# cata example to divide into copies and deletions
sub split_operations {
    my ( @ops ) = @_;
    
    my @copies;
    my @deletions;
    
    cata_operations({
        COPY   => sub { push @copies,    $_[0] },
        DELETE => sub { push @deletions, $_[0] },
    }, "", @ops);
    
    return { Copies => \@copies, Deletions => \@deletions };
}

my $split = split_operations(@changes);
@changes = ( @{$split->{Deletions}}, @{$split->{Copies}} );


# Summary
print "Summary\n";
printf "Copies:    %d\n", $amount->{Copies};
printf "Deletions: %d\n\n", $amount->{Deletions};


# dispatch-table
my $execute = {
    COPY   => sub { 
        my ( $op ) = @_;
        printf "%s %s => %s\n", red("Copying"), blue($op->src), cyan($op->dst);
        fcopy($op->src, $op->dst);
    },
    DELETE => sub {
        my ( $op ) = @_;
        printf "%s %s\n", red("Deleting"), blue($op->file);
        $op->file->remove;
    },
};

my $print = {
    COPY   => sub { printf "%s %s => %s\n", red("Copying"), blue($_[0]->src), cyan($_[0]->dst) },
    DELETE => sub { printf "%s %s\n", red("Deleting"), blue($_[0]->file) },
    _POST  => sub { print red("\nNo Copy/Delete has been done. Pass --force to do real work.\n") },
};


# Run Program
$force ? cata_operations($execute, {}, @changes)
       : cata_operations($print,   {}, @changes);



# Table: _PRE, _POST, COPY, DELETE
# Catamorphism over Operations Array
sub cata_operations {
    my ( $dispatch, $state, @operations ) = @_;
    
    die "Error: COPY does not exists in dispatch-table.\n"   if not exists $dispatch->{COPY};
    die "Error: DELETE does not exists in dispatch-table.\n" if not exists $dispatch->{DELETE};
    
    $dispatch->{_PRE}(@operations) if exists $dispatch->{_PRE};
    for my $op ( @operations ) {
        if ( $op->is_copy ) {
            $state = $dispatch->{COPY}($op, $state);
        }
        elsif ( $op->is_delete ) {
            $state = $dispatch->{DELETE}($op, $state);
        }
        else {
            die "Fatal Error: An operation was not handled.\n";
        }
    }
    $dispatch->{_POST}(@operations) if exists $dispatch->{_POST};
    
    return $state;
}


### Classes
BEGIN {
    package Operation;
    use namespace::autoclean;
    use Moose::Role;
    requires 'tag';
    sub is_copy   { $_[0]->tag eq 'COPY'   }
    sub is_delete { $_[0]->tag eq 'DELETE' }

    package Delete;
    use namespace::autoclean;
    use Moose;
    with 'Operation';
    sub tag { return 'DELETE' }
    has 'file' => (is => 'ro', isa => 'Path::Class::File', required => 1);
    
    package Copy;
    use namespace::autoclean;
    use Moose;
    with 'Operation';
    sub tag { return 'COPY' }
    has 'src' => (is => 'ro', isa => 'Path::Class::File', required => 1);
    has 'dst' => (is => 'ro', isa => 'Path::Class::File', required => 1);

    package Synchronize;
    use namespace::autoclean;
    use Moose;
    use Path::Class;
    use List::Util qw(any);
    use Types::Standard qw(InstanceOf Bool);
    use Type::Params qw(compile);
    use Moose::Util::TypeConstraints;

    class_type 'PathClassDir', { class => 'Path::Class::Dir' };

    coerce 'PathClassDir',
        from 'Str',
        via { dir($_) };

    has 'source'      => ( is => 'ro', isa => 'PathClassDir', required => 1 );
    has 'destination' => ( is => 'ro', isa => 'PathClassDir', required => 1 );
    has 'recursive'   => ( is => 'ro', isa => Bool, default => 1 );
    
    # returns full path of every file from a directory
    my sub list_files {
        my ($dir, %attr) = @_;
        my $recursive = $attr{Recursive} // 1;
        
        my $content = [];
        if ( -d $dir ) {
            if ( $recursive ) {
                $content = $dir->traverse(sub {
                    my ($child, $cont, $content) = @_;
                
                    -f $child ? push @$content, $child
                              : $cont->($content);
                
                    return $content;
                }, []);
            }
            else {
                while ( my $x = $dir->next ) {
                    push @$content, $x if -f $x;
                }
            }
        }
        
        return $content;
    }

    sub source_files {
        my ( $self ) = @_;
        return list_files($self->source, Recursive => $self->recursive);
    }

    sub destination_files {
        my ( $self ) = @_;
        return list_files($self->destination, Recursive => $self->recursive);
    }

    sub diff {
        my ( $self ) = @_;
           
        # Changes operation
        my @changes;
        
        # Fetch file list only once
        my $src = RelativeFolder->from_absolute(
            root  => $self->source,
            files => $self->source_files,
        );
        my $dst = RelativeFolder->from_absolute(
            root  => $self->destination,
            files => $self->destination_files,
        );
        
        # Which files should be deleted from DST
        for my $file ( $dst->all_files ) {
            if ( not $src->contains($file) ) {
                push @changes, Delete->new(file => $dst->root->file($file));
            }
        }
        
        # Look which files should be copied from SRC to DST
        for my $file ( $src->all_files ) {
            if ( not $dst->contains($file) ) {
                push @changes, Copy->new(src => $src->root->file($file), dst => $dst->root->file($file));
            }
        }
        
        return wantarray ? @changes : \@changes;
    }

    
    package RelativeFolder;
    use namespace::autoclean;
    use Moose;
    use Types::Standard qw(Any InstanceOf ArrayRef);
    use Type::Params qw(compile_named);
    use List::Util qw(any);
    
    has 'root' => (
        is       => 'ro',
        isa      => InstanceOf['Path::Class::Dir'],
        required => 1,
    );
    
    has 'files' => (
        traits   => ['Array'],
        is       => 'ro',
        isa      => ArrayRef[InstanceOf['Path::Class::File']],
        required => 1,
        handles  => {
            all_files => 'elements',
        }
    );
    
    sub contains {
        my ( $self, $file ) = @_;
        
        if ( any { $file eq $_ } $self->all_files ) {
            return 1;
        }
        
        return 0;
    }
    
    # Class Method
    sub from_absolute {
        state $check = compile_named(
            { head => 1 },
            root  => InstanceOf['Path::Class::Dir'],
            files => ArrayRef[InstanceOf['Path::Class::File']],
        );
        my ( $class, $arg ) = &$check;
        
        return RelativeFolder->new({
            root  => $arg->{root},
            files => [ map { $_->relative($arg->{root}) } @{$arg->{files}} ],
        });
    }
}








