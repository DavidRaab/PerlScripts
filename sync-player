#!/usr/bin/env perl
use strict;
use warnings;
use v5.32;
use FindBin;
use lib "$FindBin::RealBin";
use Color qw(red blue cyan);
use Data::Printer;
use Path::Class qw(file dir);
use File::Copy::Recursive qw(fcopy pathmk);
use List::Util qw(reduce);
use Getopt::Long;

# Todo:
# * Configuration to a file
# * Single files instead of directories

my $force = 0;
GetOptions(
    "f|force" => \$force,
) or die "Error in command line arguments\n";

# Helper Functions to create data-structure
sub sync {
    my ( $destination ) = @_;
    $destination = dir($destination);
    
    my $music = dir("/mnt/daten/Musik");
    return sub {
        my ( $folder, %attr ) = @_;
        my $recursive = $attr{Recursive} // 1;
        return Synchronize->new(
            source      => $music->subdir($folder),
            destination => $destination->subdir($folder),
            recursive   => $recursive,
        );
    }
}

*d2 = sync("/media/david/D2/MUSIC");
*sd = sync("/media/david/A770-7A18");

# Folders to Synchronize
my @synchronize = (
    d2("2019"), d2("2020"), d2("2021"), d2("2022-1"), d2("2022-2"), d2("2wei"), d2("8 Graves"), 
    d2("Adele"), d2("Apashe"),
    d2("Best of Yiruma"),
    d2("Daft Punk"), d2("Dub Fx"),
    d2("Enigma"), d2("E Nomine"), d2("Enya/Very Best of Enya"),
    d2("Foo Fighters"),
    d2("Juno Reactor"),
    d2("Games", Recursive => 0),
    sd("Keep Calm And Feel The Reggae"),
);

# All changes
my @changes = map { $_->diff } @synchronize;

# get count of each operation
my $amount = reduce {
    $b->match(
        COPY   => sub { $a->{Copies}++;    $a },
        DELETE => sub { $a->{Deletions}++; $a },
    );
} {Copies => 0, Deletions => 0}, @changes;


# split operations into copy/delete
my $ops = reduce {
    $b->match(
        COPY   => sub { push @{$a->{Copies}},    $b; $a },
        DELETE => sub { push @{$a->{Deletions}}, $b; $a },
    );
} {Copies => [], Deletions => []}, @changes;

# Re-Order operations by Deletions first
@changes = ( @{$ops->{Deletions}}, @{$ops->{Copies}} );


# Start Program by Summary
print  "Summary\n";
printf "Copies:    %d\n",   $amount->{Copies};
printf "Deletions: %d\n\n", $amount->{Deletions};

for my $op ( @changes ) {
    $op->match(
        COPY => sub {
            printf "%s %s => %s\n", red("Copying"), blue($op->src), cyan($op->dst);
            if ( $force ) {
                fcopy($op->src, $op->dst) or warn "WARNING: $!\n";
            }
        },
        DELETE => sub {
            printf "%s %s\n", red("Deleting"), blue($op->file);
            if ( $force ) {
                $op->file->remove or warn "WARNING: $!\n";
            }
        },
    );
}

if ( not $force ) {
    print red("\nNo Copy/Delete has been done. Pass --force to do real work.\n");
}

# Program End


### Classes
BEGIN {
    package Delete;
    use namespace::autoclean;
    use Moose;
    has 'file' => (is => 'ro', isa => 'Path::Class::File', required => 1);
    sub match {
        my ($self, %attr) = @_;
        $attr{DELETE}->($self);
    }
    
    package Copy;
    use namespace::autoclean;
    use Moose;
    has 'src' => (is => 'ro', isa => 'Path::Class::File', required => 1);
    has 'dst' => (is => 'ro', isa => 'Path::Class::File', required => 1);
    sub match {
        my ($self, %attr) = @_;
        $attr{COPY}->($self);
    }

    package Synchronize;
    use namespace::autoclean;
    use Moose;
    use Path::Class;
    use List::Util qw(any);
    use Types::Standard qw(InstanceOf Bool);
    use Type::Params qw(compile);
    use Moose::Util::TypeConstraints;

    class_type 'PathClassDir', { class => 'Path::Class::Dir' };

    coerce 'PathClassDir',
        from 'Str',
        via { dir($_) };

    has 'source'      => ( is => 'ro', isa => 'PathClassDir', required => 1 );
    has 'destination' => ( is => 'ro', isa => 'PathClassDir', required => 1 );
    has 'recursive'   => ( is => 'ro', isa => Bool, default => 1 );
    
    # returns full path of every file from a directory
    my sub list_files {
        my ($dir, %attr) = @_;
        my $recursive = $attr{Recursive} // 1;
        
        my $content = [];
        if ( -d $dir ) {
            if ( $recursive ) {
                $content = $dir->traverse(sub {
                    my ($x, $cont, $content) = @_;
                
                    # if file, push to content
                    if ( -f $x ) {
                        push @$content, {
                            File =>    $x,
                            Size => -s $x,
                        };                        
                    }
                    # otherwise traverse recursively
                    else {
                        $cont->($content);
                    }
                
                    return $content;
                }, []);
            }
            else {
                while ( my $x = $dir->next ) {
                    if ( -f $x ) {
                        push @$content, {
                            File =>    $x,
                            Size => -s $x,
                        };
                    }
                }
            }
        }
        
        return $content;
    }

    sub source_files {
        my ( $self ) = @_;
        return list_files($self->source, Recursive => $self->recursive);
    }

    sub destination_files {
        my ( $self ) = @_;
        return list_files($self->destination, Recursive => $self->recursive);
    }

    sub diff {
        my ( $self ) = @_;
           
        # Changes operation
        my @changes;
        
        # Fetch file list only once
        my $src = RelativeFolder->from_absolute(
            root  => $self->source,
            files => $self->source_files,
        );
        my $dst = RelativeFolder->from_absolute(
            root  => $self->destination,
            files => $self->destination_files,
        );
        
        # Which files should be deleted from DST
        for my $file ( $dst->all_files ) {
            if ( not defined $src->find_file($file->{File}) ) {
                push @changes, Delete->new(file => $dst->root->file($file->{File}));
            }
        }
        
        # Look which files should be copied from SRC to DST
        for my $src_file ( $src->all_files ) {
            my $file = $src_file->{File};
            my $size = $src_file->{Size};
            my $copy = Copy->new(
                src => $src->root->file($file),
                dst => $dst->root->file($file),
            );
        
            # Look if file exists in dst
            my $dst_file = $dst->find_file($file);
            # if file exists 
            if ( defined $dst_file ) {
                # but file size is different, then copy
                if ( $dst_file->{Size} != $size ) {
                    push @changes, $copy;
                }
            }
            # if not in dst, also copy
            else {
                push @changes, $copy;
            }
        }
        
        return wantarray ? @changes : \@changes;
    }

    
    package RelativeFolder;
    use namespace::autoclean;
    use Moose;
    use Types::Standard qw(Any InstanceOf ArrayRef Dict Int);
    use Type::Params qw(compile_named);
    
    has 'root' => (
        is       => 'ro',
        isa      => InstanceOf['Path::Class::Dir'],
        required => 1,
    );
    
    has 'files' => (
        traits   => ['Array'],
        is       => 'ro',
        isa      =>
            ArrayRef[
                Dict[
                    File => InstanceOf['Path::Class::File'],
                    Size => Int,
                ]],
        required => 1,
        handles  => {
            all_files  => 'elements',
            first_file => 'first',
        }
    );
    
    sub find_file {
        my ( $self, $file ) = @_;
        return $self->first_file(sub { $_->{File} eq $file });
    }
    
    # Class Method
    sub from_absolute {
        state $check = compile_named(
            { head => 1 },
            root  => InstanceOf['Path::Class::Dir'],
            files => ArrayRef[Dict[File => InstanceOf['Path::Class::File'], Size => Int]],
        );
        my ( $class, $arg ) = &$check;
        
        return RelativeFolder->new({
            root  => $arg->{root},
            files => [ map +{
                File => $_->{File}->relative($arg->{root}),
                Size => $_->{Size},
            }, @{$arg->{files}} ],
        });
    }
}








