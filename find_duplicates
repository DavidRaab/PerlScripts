#!/usr/bin/env perl
use v5.36;
use open ':std', ':encoding(UTF-8)';
use Path::Tiny;
use Digest::SHA qw(sha512_hex);
use Data::Printer;
use Getopt::Long::Descriptive;
use Sq;

### Argument Parsing

my ($opt, $usage) = describe_options(
    'Usage: %c %o',
    ['min|m=s',    'Minimum file-size, like: 1, 1k, 1m, .3m, 1.5m'],
    ['folder|f=s', 'De-Duplication folder'],
    ['help|h',     'Print this message', {shortcircuit => 1}],
);

$usage->die if $opt->help;

# check if folder exists and turn it into a Path::Tiny object
my $dedup;
if ( $opt->folder ) {
    $dedup = path($opt->folder);
    die "De-Duplication Folder does not exists.\n" if not $dedup->is_dir;
}

# read minimum
my $min;
if ( $opt->min ) {
    my $num = qr/ \d+ | \.\d+ | \d+\.\d+ /xms;
    if ( $opt->min =~ m/\A ($num) \s* \z/xms ) {
        $min = $1;
    }
    elsif ( $opt->min =~ m/\A ($num) \s* ([km]) \s* \z/xmsi ) {
        $min =
            $2 eq 'k'
            ? $1 * 1024
            : $1 * 1024 * 1024;
    }
    else {
        die "Unsupported minimum. Specify integer optionally followed by [km]\n";
    }
}

### Finding Duplicates

# files grouped by file-size
my $file = path('.')->visit(sub($path, $state) {
    # skip if directory
    return if $path->is_dir;
    # skip if file is smaller than minimum
    return if $min && $path->size < $min;

    push $state->{$path->size}->@*, $path;
}, { recurse => 1 });

# delete all entries that only has one file per size
hash_filter($file, sub($size, $files) {
    return @$files > 1 ? 1 : 0;
});

# go through file blocks and turn them into { SHA512 => [file] }
for my $size ( keys %$file ) {
    my %sha;
    for my $file ( $file->{$size}->@* ) {
        my $sha = sha512_hex(read_bytes($file, 4096));
        push $sha{$sha}->@*, $file;
    }
    $file->{$size} = \%sha;
}

# only keep entries that has more than one file per sha512
for my $size ( keys %$file ) {
    hash_filter($file->{$size}, sub($sha, $files) {
        return @$files > 1 ? 1 : 0
    });
}

# only keep file sizes that has some entries in it
hash_filter($file, sub($size, $sha) {
    return hash_count($sha) > 0 ? 1 : 0;
});


### Action
if ( $dedup ) {
    do_dedup($file);
}
else {
    print_potential_duplicates($file);
}


## Functions

# returns $count bytes of file, defaults to 4Kib (usually file-systems smallest unit)
sub read_bytes($path, $count=4096) {
    my $fh = $path->openr_raw;
    my $content;
    read $fh, $content, $count;
    return $content;
}

# goes through a hash and calls a callback with $key, $value
# only keeps the hash entries where $predicate returns a true-ish value
sub hash_filter($hash, $predicate) {
    while ( my ($key, $value) = each %$hash ) {
        if ( $predicate->($key, $value) ) {
            # if true - do nothing
        }
        else {
            delete $hash->{$key};
        }
    }
    return;
}

# returns the amount of entries in a hash
sub hash_count($hash) {
    return scalar keys %$hash;
}

sub print_potential_duplicates($data) {
    for my $size ( sort { $a <=> $b } keys %$data ) {
        for my $sha ( keys $data->{$size}->%* ) {
            printf "SHA512 %s - %d bytes\n", $sha, $size;
            Array::iter($data->{$size}{$sha}, sub($file) {
                say $file;
            });
            print "\n";
        }
    }
}

sub do_dedup($data) {
    for my $size ( sort { $a <=> $b } keys %$data ) {
        for my $sha ( keys $data->{$size}->%* ) {
            printf "File-Size: %d bytes\n", $size;
            Array::iteri($data->{$size}{$sha}, sub($file, $idx) {
                printf "%02d. %s\n", $idx+1, $file;
            });

            if ( ask("De-Duplicate? [yes/no*]") ) {

                say "DEDUP";
            }
            else {
                say "SKIP";
            }
        }
    }
}

sub ask($message) {
    $message =~ s/\s*$/ /xmsi;
    print $message;
    my $input = <STDIN>;
    if ( $input =~ m/\A ( y | ye | yes ) $/xmsi ) {
        return 1;
    }
    return;
}
